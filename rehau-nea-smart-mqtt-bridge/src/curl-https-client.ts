import { execSync } from 'child_process';
import { CookieJar } from 'tough-cookie';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

interface RequestOptions {
  method?: string;
  headers?: Record<string, string>;
  body?: string;
  maxRedirects?: number;
}

interface Response {
  statusCode: number;
  headers: Record<string, string>;
  body: string;
  data: any;
  status: number;
  finalUrl: string;
}

export class CurlHttpsClient {
  private jar: CookieJar;
  private cookieFile: string;

  constructor() {
    this.jar = new CookieJar();
    // Create a temporary cookie file for curl
    this.cookieFile = path.join(os.tmpdir(), `rehau-cookies-${Date.now()}.txt`);
  }

  private async saveCookies(url: string): Promise<void> {
    const cookies = await this.jar.getCookies(url);
    const cookieLines = cookies.map(cookie => {
      // Netscape cookie format for curl
      const domain = cookie.domain || '';
      const flag = domain.startsWith('.') ? 'TRUE' : 'FALSE';
      const path = cookie.path || '/';
      const secure = cookie.secure ? 'TRUE' : 'FALSE';
      const expiration = cookie.expires && cookie.expires !== 'Infinity' ? Math.floor(cookie.expires.getTime() / 1000) : 0;
      const name = cookie.key;
      const value = cookie.value;
      return `${domain}\t${flag}\t${path}\t${secure}\t${expiration}\t${name}\t${value}`;
    });
    
    const header = '# Netscape HTTP Cookie File\n# This file was generated by rehau-nea-smart\n\n';
    fs.writeFileSync(this.cookieFile, header + cookieLines.join('\n'));
  }

  private async loadCookies(url: string, setCookieHeaders: string[]): Promise<void> {
    for (const cookieStr of setCookieHeaders) {
      await this.jar.setCookie(cookieStr, url);
    }
  }

  private parseResponse(curlOutput: string): { statusCode: number; headers: Record<string, string>; body: string; finalUrl: string } {
    const lines = curlOutput.split('\n');
    let statusCode = 0;
    const headers: Record<string, string> = {};
    let bodyStartIndex = 0;
    let finalUrl = '';

    // Parse headers
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      // HTTP status line
      if (line.startsWith('HTTP/')) {
        const match = line.match(/HTTP\/[\d.]+ (\d+)/);
        if (match) {
          statusCode = parseInt(match[1], 10);
        }
      }
      // Header line
      else if (line.includes(':') && !line.startsWith('{') && !line.startsWith('<') && !line.startsWith('HTTP/')) {
        const colonIndex = line.indexOf(':');
        const key = line.substring(0, colonIndex).trim().toLowerCase();
        const value = line.substring(colonIndex + 1).trim();
        if (key && value) {
          headers[key] = value;
          // Capture Location header as finalUrl
          if (key === 'location') {
            finalUrl = value;
          }
        }
      }
      // Empty line marks end of headers
      else if (line.trim() === '' && statusCode > 0) {
        bodyStartIndex = i + 1;
        break;
      }
    }

    const body = lines.slice(bodyStartIndex).join('\n');
    return { statusCode, headers, body, finalUrl };
  }

  async request(url: string, options: RequestOptions = {}): Promise<Response> {
    const method = options.method || 'GET';
    const maxRedirects = options.maxRedirects ?? 0;
    
    // Save cookies to file for curl
    await this.saveCookies(url);

    // Build curl command
    const curlArgs: string[] = [
      'curl',
      '-i', // Include headers in output
      '-s', // Silent mode
      '-S', // Show errors
      '-L', // Follow redirects
      `--max-redirs ${maxRedirects}`,
      `-X ${method}`,
      `-b "${this.cookieFile}"`, // Load cookies
      `-c "${this.cookieFile}"`, // Save cookies
    ];

    // Add headers
    if (options.headers) {
      for (const [key, value] of Object.entries(options.headers)) {
        curlArgs.push(`-H "${key}: ${value}"`);
      }
    }

    // Add body for POST requests
    if (options.body && method === 'POST') {
      curlArgs.push(`-d "${options.body.replace(/"/g, '\\"')}"`);
    }

    // Add URL
    curlArgs.push(`"${url}"`);

    const curlCommand = curlArgs.join(' ');
    
    try {
      process.stderr.write(`[CurlHttpsClient] Executing: ${curlCommand.substring(0, 200)}...\n`);
      
      const output = execSync(curlCommand, {
        encoding: 'utf-8',
        maxBuffer: 10 * 1024 * 1024, // 10MB buffer
        stdio: ['pipe', 'pipe', 'pipe']
      });

      const parsed = this.parseResponse(output);
      
      // Load cookies from response
      if (parsed.headers['set-cookie']) {
        const setCookies = Array.isArray(parsed.headers['set-cookie']) 
          ? parsed.headers['set-cookie'] 
          : [parsed.headers['set-cookie']];
        await this.loadCookies(url, setCookies);
      }

      // Parse JSON if content-type indicates it
      let parsedData = parsed.body;
      const contentType = parsed.headers['content-type'];
      if (contentType && contentType.includes('application/json') && parsed.body) {
        try {
          parsedData = JSON.parse(parsed.body);
        } catch (e) {
          // Keep as string if JSON parse fails
        }
      }

      process.stderr.write(`[CurlHttpsClient] Response: ${parsed.statusCode} ${parsed.body.length} bytes\n`);

      return {
        statusCode: parsed.statusCode,
        headers: parsed.headers,
        body: parsed.body,
        data: parsedData,
        status: parsed.statusCode,
        finalUrl: parsed.finalUrl || url
      };
    } catch (error: any) {
      process.stderr.write(`[CurlHttpsClient] Error: ${error.message}\n`);
      throw new Error(`Curl request failed: ${error.message}`);
    }
  }

  async get(url: string, options: RequestOptions = {}): Promise<Response> {
    return this.request(url, { ...options, method: 'GET' });
  }

  async post(url: string, body: string, options: RequestOptions = {}): Promise<Response> {
    return this.request(url, { ...options, method: 'POST', body });
  }

  cleanup(): void {
    // Clean up temporary cookie file
    if (fs.existsSync(this.cookieFile)) {
      fs.unlinkSync(this.cookieFile);
    }
  }
}
